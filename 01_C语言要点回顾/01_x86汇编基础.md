# x86汇编基础

> x86汇编存在intel和AT&T两种写法。一般windows用intel写法，unix用at&t写法。这里是后者

## 最简单的汇编程序

一般来讲，汇编程序的文件以`.s`结尾。用汇编器汇编之后的目标文件以`.o`结尾。

GNU中有两个工具:

- as，汇编器（assembler），把`.s`的汇编程序翻译成机器指令，生成目标文件
- ld，linker，把`.o`的目标文件链接成可执行程序

现在来看一个最简单的汇编程序，相当于在c的main函数中一个`return 4`。`echo $?`可以打印上次执行的命令的退出状态

```
 .section .data

 .section .text
 .globl _start
_start:
 movl $1, %eax    # this is linux kernel command number (system call) 
                  # for exiting a program
 movl $4, %ebx

 int $0x80        # this wakes up kernel to run the exit command
```

先汇编，再链接，再执行，然后看看退出状态是4。这就是我们预期的结果

```
(base) root test (master) # as -o hello.o hello.s 
(base) root test (master) # ld -o hello hello.o
(base) root test (master) # ./hello 
(base) root test (master) # echo $?
4
```

现在来分析一下这段汇编程序。

汇编程序中以`.`开头的不是助记符，不会被翻译成机器指令。这时给汇编器看的`汇编指示（Assembler Directive）`

- `.section`的作用是把指令划分为若干段。程序加载时，操作系统会把不同的段加载到不同的内存地址。
- `.data`段保存数据，可读可写。本程序没有数据，所以是空的
- `.text`段是代码段，可读可执行。后面的指令都属于`.text`段
- `_start`是一个符号，代表一个内存地址。c中执行一个函数，就是跳到函数代码的地址去执行。这里`_start`的作用类似于c中的`mian`。在`_start:`中的内容就会被最先执行。
- `.globl`把`_start`符号标记为一个全局符号。

```
 movl $1, %eax
```

这条语句的作用是在CPU中生成一个立即数（即在CPU内部产生的数）1，并送到寄存器eax中。

- $开头的数是立即数
- %开头后面接的是寄存器名
- mov表示是传送数据。l表示是long，即32位

```
 int $0x80
```

- int是软终端指令，可以产生一个异常。CPU会从用户模式切换到特权模式，然后跳转到内核代码中执行异常处理程序。Linux的各种系统调用都是由`int $0x80`指令引发。eax的值是系统调用号，这里是1，即会调用`_exit`，ebx的值是传给_exit的参数，表示退出状态。

## x86的寄存器

通用寄存器有`eax`、`ebx`、`ecx`、`edx`、`edi`、`esi`。大多数都是通用的，但一些指令会对操作数存放的寄存器有限制。

特殊寄存器有：

- eip：程序计数器
- eflags：保存计算过程中的标志位，如进位标志、溢出标志、零标志、负数标志灯
- ebp，esp：用于维护函数调用的栈帧

## 第二个汇编程序 -- 求一个数组的最大值



